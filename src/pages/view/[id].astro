---
// src/pages/view/[id].astro - Direct HTML rendering page
// This page directly renders user HTML content without iframe

import { DatabaseService, getDatabase } from '../../lib/database';
import { getCacheService } from '../../lib/cache';
import { SecurityService } from '../../lib/security';

const { id } = Astro.params;

if (!id) {
  return Astro.redirect('/');
}

// Get database and cache from Cloudflare environment
const db = getDatabase(Astro.locals);
const cache = getCacheService(Astro.locals);

if (!db) {
  return new Response('Database not available', { status: 500 });
}

// Fetch page content with cache support
let pageData = null;
try {
  const dbService = new DatabaseService(db, cache);
  pageData = await dbService.getPageByUrlId(id as string);

  if (pageData) {
    // Increment view count
    await dbService.incrementViewCount(id as string);
  }
} catch (error) {
  console.error('Database error:', error);
}

if (!pageData) {
  // Return 404 page
  return new Response(`
    <!DOCTYPE html>
    <html lang="zh-CN">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>é¡µé¢æœªæ‰¾åˆ° - HTMLShare</title>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
                margin: 0;
                padding: 0;
                display: flex;
                align-items: center;
                justify-content: center;
                min-height: 100vh;
                background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            }
            .container {
                text-align: center;
                background: white;
                padding: 3rem 2rem;
                border-radius: 1rem;
                box-shadow: 0 10px 25px rgba(0,0,0,0.1);
                max-width: 500px;
                width: 90%;
            }
            h1 { color: #333; margin-bottom: 1rem; }
            p { color: #666; margin-bottom: 2rem; line-height: 1.6; }
            .btn {
                display: inline-block;
                padding: 12px 24px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                text-decoration: none;
                border-radius: 8px;
                font-weight: 500;
                transition: transform 0.2s;
            }
            .btn:hover { transform: translateY(-2px); }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>ğŸ” é¡µé¢æœªæ‰¾åˆ°</h1>
            <p>æŠ±æ­‰ï¼Œæ‚¨è®¿é—®çš„HTMLé¡µé¢ä¸å­˜åœ¨æˆ–å·²è¢«åˆ é™¤ã€‚</p>
            <a href="/" class="btn">è¿”å›é¦–é¡µ</a>
        </div>
    </body>
    </html>
  `, {
    status: 404,
    headers: { 'Content-Type': 'text/html; charset=utf-8' }
  });
}

// Set appropriate headers for direct HTML rendering with enhanced security
const headers = new Headers();
headers.set('Content-Type', 'text/html; charset=utf-8');
headers.set('Cache-Control', 'public, max-age=3600'); // Cache for 1 hour

// Enhanced security headers
const securityHeaders = SecurityService.getSecurityHeaders();
Object.entries(securityHeaders).forEach(([key, value]) => {
  headers.set(key, value);
});

// Optimized CSP for user-generated content
headers.set('Content-Security-Policy', SecurityService.getCSPHeader());

// Allow cross-origin requests for external resources
headers.set('Cross-Origin-Embedder-Policy', 'unsafe-none');
headers.set('Cross-Origin-Opener-Policy', 'unsafe-none');

// Process HTML content to ensure better rendering
let processedContent = pageData.content;

// Ensure the HTML has proper DOCTYPE if missing
if (!processedContent.trim().toLowerCase().startsWith('<!doctype')) {
  processedContent = '<!DOCTYPE html>\n' + processedContent;
}

// Add meta tags for better rendering if HTML doesn't have proper head section
if (!processedContent.toLowerCase().includes('<meta charset') && !processedContent.toLowerCase().includes('<meta http-equiv="content-type"')) {
  // Find head tag or create one
  const headTagMatch = processedContent.match(/<head[^>]*>/i);
  if (headTagMatch) {
    // Insert after opening head tag
    const headEndIndex = processedContent.indexOf('>', headTagMatch.index) + 1;
    processedContent = processedContent.slice(0, headEndIndex) +
      '\n<meta charset="UTF-8">\n<meta name="viewport" content="width=device-width, initial-scale=1.0">\n' +
      processedContent.slice(headEndIndex);
  } else if (processedContent.toLowerCase().includes('<html')) {
    // Insert after html tag
    const htmlTagMatch = processedContent.match(/<html[^>]*>/i);
    if (htmlTagMatch) {
      const htmlEndIndex = processedContent.indexOf('>', htmlTagMatch.index) + 1;
      processedContent = processedContent.slice(0, htmlEndIndex) +
        '\n<head>\n<meta charset="UTF-8">\n<meta name="viewport" content="width=device-width, initial-scale=1.0">\n</head>\n' +
        processedContent.slice(htmlEndIndex);
    }
  }
}

// Directly return the processed HTML content
// This approach ensures external resources can load properly
return new Response(processedContent, {
  status: 200,
  headers: headers
});
---